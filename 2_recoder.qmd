---
output: html_document
editor_options: 
  chunk_output_type: console
---
# Recoder des variables {#sec-vectorfactor}

## Rappel sur les variables et les vecteurs {#sec-vecteurs}

Dans R, une variable, en général une colonne d'un tableau de données, est un objet de type *vecteur*. Un vecteur est un ensemble d'éléments, tous du même type. Dans ce qui suit on va utiliser le jeu de données d'exemple `hdv2003` de l'extension `questionr`.

```{r}
library(questionr)
data(hdv2003)
```

On peut facilement créer de nouvelles variables (ou colonnes) dans un tableau de données en utilisant le `$` dans une assignation :

```{r}
hdv2003$minutes.tv <- hdv2003$heures.tv * 60
```

Les vecteurs peuvent être de classes différentes, selon le type de données qu'ils contiennent.

On a ainsi des vecteurs de type `integer` ou `double`, qui contiennent respectivement des nombres entiers ou décimaux :

```{r}
typeof(hdv2003$age)
```

```{r}
typeof(hdv2003$heures.tv)
```

Des vecteurs de type `character`, qui contiennent des chaînes de caractères :

```{r}
vec <- c("Jaune", "Jaune", "Rouge", "Vert")
typeof(vec)
```

Et des vecteurs de type `logical`, qui ne peuvent contenir que les valeurs vraie (`TRUE`) ou fausse (`FALSE`).

```{r}
vec <- c(TRUE, FALSE, FALSE, TRUE)
typeof(vec)
```

On peut convertir un vecteur d'un type en un autre en utilisant les fonctions `as.numeric`, `as.character` ou `as.logical`. Les valeurs qui n'ont pas pu être converties sont automatiquement transformées en `NA`.

```{r}
x <- c("1", "2.35", "8.2e+03", "foo")
as.numeric(x)

y <- 2:6
as.character(y)

```

On peut sélectionner certains éléments d'un vecteur à l'aide de l'opérateur `[]`. La manière la plus simple est d'indiquer la position des éléments qu'on veut sélectionner :

```{r}
vec <- c("Jaune", "Jaune", "Rouge", "Vert")
vec[c(1, 3)]
```

La sélection peut aussi être utilisée pour modifier certains éléments d'un vecteur, par exemple :

```{r}
vec <- c("Jaune", "Jaune", "Rouge", "Vert")
vec[2] <- "Violet"
vec
```

## Tests et comparaison {#sec-tests}

Un test est une opération logique de comparaison qui renvoie vrai (`TRUE`) ou faux (`FALSE`) pour chacun des éléments d'un vecteur.

Parmi les opérateurs de comparaison disponibles, on trouve notamment :

-   `==` qui teste l'égalité
-   `!=` qui teste la différence
-   `>`, `<`, `<=`, `>=` qui testent la supériorité ou l'infériorité
-   `%in%` qui teste l'appartenance à un ensemble de valeurs

Exemple le plus simple :

```{r}
2 == 3
```

```{r}
2 != 3
```

Exemple appliqué à un vecteur :

```{r}
x <- 1:10
x < 5
```

On peut combiner plusieurs tests avec les opérateurs logiques *et* (`&`) et *ou* (`|`). Ainsi, si on veut tester qu'une valeur est comprise entre 3 et 6 inclus, on peut faire :

```{r}
x >= 3 & x <= 6
```

Si on veut tester qu'une valeur est égale à "Bleu" ou à "Vert", on peut faire :

```{r}
vec <- c("Jaune", "Jaune", "Rouge", "Vert")
vec == "Jaune" | vec == "Vert"
```

À noter que dans ce cas, on peut utiliser l'opérateur `%in%`[^4], qui teste si une valeur fait partie des éléments d'un vecteur :

[^4]: Pour accéder à la page de documentation de fonctions comme `%in%`, on ne peut pas utiliser `?%in%`, qui renvoie une erreur. Vous pouvez faire `?"%in%"`, `help("%in%")` ou, dans ce cas, `?match`, car les deux fonctions sont documentées sur la même page d'aide.

```{r}
vec %in% c("Jaune", "Vert")
```

::: callout-warning
Attention, si on souhaite tester si une valeur `x` est inconnue (ou 'manquante'), c'est-à-dire si elle est codée `NA` (*Not Available*), faire le test `x == NA` *ne donnera pas le résultat escompté*. En effet, fidèle à sa réputation de rigueur informaticienne, pour R `NA == NA` ne vaut pas `TRUE` mais... `NA` (on ne sait pas si une valeur inconnue est égale à une autre valeur inconnue).

Pour tester si une valeur est inconnue (`NA`), il faut utiliser la fonction dédiée `is.na` et faire `is.na(x)`.

Cependant, par convention, `NA %in% NA` vaut `TRUE`.
:::

Enfin, on peut inverser un test avec l'opérateur *non* (`!`) :

```{r}
!(vec %in% c("Jaune", "Vert"))
```

## Recoder une variable qualitative {#sec-recoder-une-variable-qualitative}

Pour rappel, on appelle variable qualitative une variable pouvant prendre un nombre limité de modalités (de valeurs possibles).

### Facteurs et `forcats` {#sec-facteurs}

Dans R, les variables qualitatives peuvent être de deux types : ou bien des vecteurs de type `character` (des chaînes de caractères), ou bien des `factor` (facteurs). Si vous utilisez les fonctions des extensions du *tidyverse* comme `readr`, `readxl` ou `haven` pour importer vos données, vos variables qualitatives seront importées sous forme de `character`. Mais dans d'autres cas elles se retrouveront parfois sous forme de `factor`. C'est le cas de notre jeu de données d'exemple `hdv2003`.

```{r}
class(hdv2003$qualif)
```

Les facteurs sont un type de variable ne pouvant prendre qu'un nombre défini de modalités nommés *levels*.

```{r}
levels(hdv2003$qualif)
```

Ceci complique les opérations de recodage car du coup l'opération suivante, qui tente de modifier une modalité de la variable, aboutit à un avertissement, et l'opération n'est pas effectuée.

```{r}
hdv2003$qualif[hdv2003$qualif == "Ouvrier specialise"] <- "Ouvrier"
```

`forcats` est une extension facilitant la manipulation des variables qualitatives, qu'elles soient sous forme de vecteurs `character` ou de facteurs. Elle fait partie du *tidyverse*, et est donc automatiquement chargée par :

```{r}
library(tidyverse)
```

### Modifier les modalités d'une variable qualitative {#sec-recode}

Une opération courante consiste à modifier les valeurs d'une variable qualitative, que ce soit pour avoir des intitulés plus courts ou plus clairs ou pour regrouper des modalités entre elles.

Il existe plusieurs possibilités pour effectuer ce type de recodage, mais ici on va utiliser la fonction `fct_recode` de l'extension `forcats`. Celle-ci prend en argument une liste de recodages sous la forme `"Nouvelle valeur" = "Ancienne valeur"`.

Un exemple :

```{r}
f <- c("Pomme", "Poire", "Pomme", "Cerise")
f <- fct_recode(
    f,
    "Fraise" = "Pomme",
    "Ananas" = "Poire"
)
f
```

```{r}
hdv2003$qualif5 <- fct_recode(
    hdv2003$qualif,
    "Ouvrier" = "Ouvrier specialise",
    "Ouvrier" = "Ouvrier qualifie",
    "Interm" = "Technicien",
    "Interm" = "Profession intermediaire"
)

```

Attention, les anciennes valeurs saisies doivent être exactement égales aux valeurs des modalités de la variable recodée : toute différence d'accent ou d'espace fera que ce recodage ne sera pas pris en compte. Dans ce cas, `forcats` affiche un avertissement nous indiquant qu'une valeur saisie n'a pas été trouvée dans les modalités de la variable.

```{r}
hdv2003$qualif_test <- fct_recode(
    hdv2003$qualif,
    "Ouvrier" = "Ouvrier spécialisé",
    "Ouvrier" = "Ouvrier qualifié"
)
```

Si on souhaite recoder une modalité de la variable en `NA`, il faut (contre intuitivement) lui assigner la valeur `NULL`.

```{r}
hdv2003$qualif_rec <- fct_recode(
    hdv2003$qualif, 
    NULL = "Autre"
)
table(hdv2003$qualif, useNA = "ifany")
table(hdv2003$qualif_rec)
```

À l'inverse, si on souhaite recoder les `NA` d'une variable, on utilisera la fonction `fct_explicit_na`, qui convertit toutes les valeurs manquantes (`NA`) d'un facteur en une modalité spécifique.

```{r}
hdv2003$qualif_rec <- fct_explicit_na(hdv2003$qualif, na_level = "(Manquant)")
table(hdv2003$qualif_rec)
```

#### Interface graphique de recodage {#sec-irec}

L'extension `questionr` propose une interface graphique facilitant le recodage des modalités d'une variable qualitative. L'objectif est de permettre à la personne qui l'utilise de saisir les nouvelles valeurs dans un formulaire, et de générer ensuite le code R correspondant au recodage indiqué.

Pour utiliser cette interface, sous RStudio vous pouvez aller dans le menu *Addins* (présent dans la barre d'outils principale) puis choisir *Levels recoding*. Sinon, vous pouvez lancer dans la console la fonction `irec()` en lui passant comme paramètre la variable à recoder.

L'interface se compose de trois onglets : l'onglet *Variable et paramètres* vous permet de sélectionner la variable à recoder, le nom de la nouvelle variable et d'autres paramètres, l'onglet *Recodages* vous permet de saisir les nouvelles valeurs des modalités, et l'onglet *Code et résultat* affiche le code R correspondant ainsi qu'un tableau permettant de vérifier les résultats.

Une fois votre recodage terminé, cliquez sur le bouton *Done* et le code R sera inséré dans votre script R ou affiché dans la console.

::: callout-warning
**Attention**, cette interface est prévue pour ne pas modifier vos données. C'est donc à vous d'exécuter le code généré pour que le recodage soit réellement effectif.
:::

```{r}
irec(hdv2003$qualif)
```

### Ordonner les modalités d'une variable qualitative

L'avantage des facteurs (par rapport aux vecteurs de type `character`) est que leurs modalités peuvent être ordonnées, ce qui peut faciliter la lecture de tableaux ou graphiques.

On peut ordonner les modalités d'un facteur manuellement, par exemple avec la fonction `fct_relevel()` de l'extension `forcats`.

```{r}
hdv2003$qualif_rec <- fct_relevel(
    hdv2003$qualif,
    "Cadre", "Profession intermediaire", "Technicien",
    "Employe", "Ouvrier qualifie", "Ouvrier specialise",
    "Autre"
)

table(hdv2003$qualif_rec)
```

Une autre possibilité est d'ordonner les modalités d'un facteur selon les valeurs d'une autre variable. Par exemple, si on représente le boxplot de la répartition de l'âge selon le statut d'occupation :

```{r warning=FALSE}
# Le package ggplot2 sera présenté plus bas
library(ggplot2)
ggplot(hdv2003) +
  geom_boxplot(aes(x = occup, y = age))
```

Le graphique pourrait être plus lisible si les modalités étaient triées par âge median croissant. On peut dans ce cas utiliser la fonction `fct_reorder`. Celle-ci prend 3 arguments : le facteur à réordonner, la variable dont les valeurs doivent être utilisées pour ce réordonnancement, et enfin une fonction à appliquer à cette deuxième variable.

```{r warning=FALSE}
hdv2003$occup_age <- fct_reorder(hdv2003$occup, hdv2003$age, median)

ggplot(hdv2003) +
  geom_boxplot(aes(x = occup_age, y = age))
```

On verra plus tard qu'on peut effectuer le réordonnancement directement dans l'appel à `ggplot2`, sans créer de nouvelle variable. Lorsqu'on effectue un diagramme en barres avec `geom_bar`, on peut aussi réordonner les modalités selon leurs effectifs à l'aide de `fct_infreq`.

```{r}
hdv2003$occup_freq <- fct_infreq(hdv2003$occup)

ggplot(hdv2003) +
  geom_bar(aes(x = occup_freq))
```

#### Interface graphique {#sec-iorder}

`questionr` propose une interface graphique afin de faciliter les opérations de réordonnancement manuel. Pour la lancer, sélectionner le menu *Addins* puis *Levels ordering*, ou exécuter la fonction `iorder()` en lui passant comme paramètre le facteur à réordonner.

```{r}
iorder(hdv2003$occup)
```

Le fonctionnement de l'interface est similaire à celui de l'interface de recodage. Vous pouvez réordonner les modalités en les faisant glisser avec la souris, puis récupérer et exécuter le code R généré.

## Combiner plusieurs variables

Parfois, on veut créer une nouvelle variable en partant des valeurs d'une ou plusieurs autres variables. Dans ce cas on peut utiliser les fonctions `ifelse` pour les cas les plus simples, ou `case_when` pour les cas plus complexes. Cette dernière fonction est incluse dans l'extension `dplyr`, qu'il faut donc avoir chargé précédemment.

### `ifelse` {#sec-if-else}

`ifelse` prend trois arguments : un test, une valeur à renvoyer si le test est vrai, et une valeur à renvoyer si le test est faux.

Voici un exemple simple :

```{r}
v <- c(12, 14, 8, 16)
ifelse(v > 10, "Supérieur à 10", "Inférieur à 10")
```

La fonction permet d'utiliser des tests combinant plusieurs variables. Par exemple, imaginons qu'on souhaite créer une nouvelle variable indiquant les hommes de plus de 60 ans :

```{r}
hdv2003$statut <- ifelse(
    hdv2003$sexe == "Homme" & hdv2003$age > 60,
    "Homme de plus de 60 ans",
    "Autre"
)

table(hdv2003$statut)
```

### `case_when`

`case_when` est une généralisation du `ifelse` qui permet d'indiquer plusieurs tests et leurs valeurs associées.

Imaginons qu'on souhaite créer une nouvelle variable permettant d'identifier les hommes de plus de 60 ans, les femmes de plus de 60 ans, et les autres. On peut utiliser la syntaxe suivante :

```{r}
hdv2003$statut <- case_when(
    hdv2003$age > 60 & hdv2003$sexe == "Homme" ~ "Homme de plus de 60 ans",
    hdv2003$age > 60 & hdv2003$sexe == "Femme" ~ "Femme de plus de 60 ans",
    TRUE ~ "Autre"
)

table(hdv2003$statut)
```

`case_when` prend en arguments une série d'instructions sous la forme `condition ~ valeur`. Il les exécute une par une, et dès qu'une `condition` est vraie, il renvoie la `valeur` associée.

La dernière clause `TRUE ~ "Autre"` permet d'assigner une valeur à toutes les lignes pour lesquelles aucune des conditions précédentes n'est vraie.

::: callout-warning
**Attention :** comme les conditions sont testées l'une après l'autre et que la valeur renvoyée est celle correspondant à la première condition vraie, l'ordre de ces conditions est très important. Il faut absolument aller du plus spécifique au plus général.
:::

Pour illustrer cet avertissement, on pourra noter que le recodage suivant ne fonctionne pas :

```{r}
hdv2003$statut <- case_when(
    hdv2003$sexe == "Homme" ~ "Homme",
    hdv2003$sexe == "Homme" & hdv2003$age > 60 ~ "Homme de plus de 60 ans",
    TRUE ~ "Autre"
)

table(hdv2003$statut)
```

Comme la condition `sexe == "Homme"` est plus générale que `sexe == "Homme" & age > 60`, cette deuxième condition n'est jamais testée, et on n'obtiendra donc jamais la valeur correspondante.

Pour que ce recodage fonctionne il faut donc changer l'ordre des conditions pour aller du plus spécifique au plus général.

```{r}
hdv2003$statut <- case_when(
    hdv2003$sexe == "Homme" & hdv2003$age > 60 ~ "Homme de plus de 60 ans",
    hdv2003$sexe == "Homme" ~ "Homme",
    TRUE ~ "Autre"
)

table(hdv2003$statut)
```

## Découper une variable numérique en classes

Une autre opération courante consiste à découper une variable numérique en classes. Par exemple, on voudra transformer une variable *revenu* contenant le revenu mensuel en une variable qualitative avec des catégories *Moins de 500 euros*, *501-1000 euros*, etc.

On utilise pour cela la fonction `cut()` :

```{r}
hdv2003$agecl <- cut(hdv2003$age, breaks = 5)

table(hdv2003$agecl)
```

Si on donne un nombre entier à l'argument `breaks`, un nombre correspondant de classes d'amplitudes égales sont automatiquement calculées. Comme il est souvent préférable d'avoir des limites "arrondies", on peut aussi spécifier ces dernières manuellement en passant un vecteur à `breaks`.

```{r}
hdv2003$agecl <- cut(
    hdv2003$age,
    breaks = c(18, 25, 35, 45, 55, 65, 97),
    include.lowest = TRUE
)

table(hdv2003$agecl)
```

Ici on a été obligé d'ajouter l'argument `include.lowest = TRUE` car sinon la valeur 18 n'aurait pas été incluse, et on aurait eu des valeurs manquantes.

### Interface graphique

Comme l'utilisation des arguments de `cut` n'est pas toujours très intuitive, l'extension `questionr` propose une interface graphique facilitant cette opération de découpage en classes d'une variable numérique.

Pour lancer cette interface, sous RStudio ouvrir le menu *Addins* et sélectionner *Numeric range dividing*, ou exécuter la fonction `icut()` dans la console en lui passant comme argument la variable quantitative à découper.

Vous pouvez alors choisir la variable à découper dans l'onglet *Variable et paramètres*, indiquer les limites de vos classes ainsi que quelques options complémentaires dans l'onglet *Découpage en classes*, et vérifier le résultat dans l'onglet *Code et résultat*. Une fois le résultat satisfaisant, cliquez sur *Done* : si vous êtes sous RStudio le code généré sera directement inséré dans votre script actuel à l'emplacement du curseur. Sinon, ce code sera affiché dans la console et vous pourrez le copier/coller pour l'inclure dans votre script.

::: callout-warning
**Attention**, cette interface est prévue pour ne pas modifier vos données. C'est donc à vous d'exécuter le code généré pour que le découpage soit réellement effectif.
:::

```{r}
icut(hdv2003$age)
```


## Exercices

### Préparation

Pour la plupart de ces exercices, on a besoin des extensions `forcats` et `questionr`, et du jeu de données d'exemple `hdv2003`.

```{r}
library(forcats)
library(questionr)
data(hdv2003)
```

### Vecteurs et tests

**Exercice 1.1**

Construire le vecteur x avec les valeurs `"12" "3.5" "421" "2,4"` et le convertir en vecteur numérique. Que remarquez-vous ?

```{r}
```

**Exercice 1.2**

Construire le vecteur x contenant les valeurs `1, 20, 21, 15.5, 14, 12, 8`. Écrire le test qui indique si tous les éléments du vecteur sont strictement supérieurs à 15.

```{r}
```

**Exercice 1.3**

Le code suivant génère un vecteur de 1000 nombres aléatoires compris entre 0 et 10 :

```{r}
x <- runif(1000, 0, 10)
```

Combien d'éléments de ce vecteur sont compris entre 2 et 4 ?

```{r}

```


### Recodages de variable qualitative

**Exercice 2.1**

Construire un vecteur `f` à l'aide du code suivant :

```{r}
f <- c("Jan", "Jan", "Fev", "Juil")
```

Recoder le vecteur à l'aide de la fonction `fct_recode` pour que le nom des mois soit complet.

```{r}
```


**Exercice 2.2**

À l'aide de l'interface graphique de `questionr`, recoder la variable `relig` du jeu de données `hdv2003` pour opposer les pratiquant·es et les non-pratiquant·es :

```{r}
```

**Exercice 2.3**

À l'aide de l'interface graphique de `questionr`, recoder la variable `nivetud` qui oppose l'étude jusqu'au collège, jusqu'au lycée et au-delà du bac.

```{r}
```

Toujours à l'aide de l'interface graphique, réordonner les modalités de cette variable recodée pour que les études supérieures apparaissent en premier.

```{r}
```


**Exercice 2.4**

À l'aide de la fonction `fct_reorder`, trier les modalités de la variable `relig` du jeu de données `hdv2003` selon leur âge médian.

```{r}
```

### Combiner plusieurs variables

**Exercice 3.1**

À l'aide de la fonction `ifelse`, créer une nouvelle variable `cinema_bd` permettant d'identifier les personnes qui vont au cinéma et déclarent lire des bandes dessinées. 

```{r}
```

**Exercice 3.2**

À l'aide de la fonction `case_when`, créer une nouvelle variable ayant les modalités suivantes :

-   Homme ayant plus de 2 frères et soeurs
-   Femme ayant plus de 2 frères et soeurs
-   Autre


```{r}
```


**Exercice 3.3**

À l'aide de la fonction `case_when`, créer une nouvelle variable ayant les modalités suivantes :

-   Homme de plus de 30 ans
-   Homme de plus de 40 ans satisfait par son travail
-   Femme pratiquant le sport ou le bricolage
-   Autre


```{r}
```


### Découper une variable numérique

**Exercice 4.1**

Dans le jeu de données `hdv2003`, découper la variable `heures.tv` en classes de manière à obtenir au final le tri à plat suivant :

```{r}
```
