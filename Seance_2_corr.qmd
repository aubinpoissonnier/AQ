---
title: "Séance 2"
format: html
editor: visual
editor_options: 
  chunk_output_type: console
---

```{r}
#| include: false
rp <- aws.s3::s3read_using(FUN = data.table::fread,
                           object = "/diffusion/RP/rp69_2017.csv",
                           bucket = "aubinpoissonnier",
                           opts = list("region" = ""))
```

# Compter avec des variables catégorielles

Vous travaillez ici avec les données du recensement anonymisées, publiées sous forme d'un fichier comportant une ligne par individu. La base `rp` correspond au recensement de 2017 pour le département du rhône. Le dictionnaire des codes est disponible à [cette adresse](https://www.insee.fr/fr/statistiques/4802064?sommaire=4508161#dictionnaire).

## Tri à plat et tri croisé

### Compter les effectifs absolus

La fonction `table` fait partie des fonctions intégrées au R de base. Elle permet de réaliser des tris à plat sur un vecteur et des tris croisés sur deux vecteurs.

Le tableau `rp` contient une colonne `sexe` qui correspond à la variable qui vaut 1 si l'individu recensé est un homme et 2 si l'individu est une femme. On peut compter le nombre d'hommes et de femmes :

```{r}
table(rp$sexe)
```

On peut aussi connaître le nombre de personnes en couple grâce à la colonne `couple`

```{r}
table(rp$couple)
```

### Calculer les pourcentages

Souvent, on cherche plutôt à obtenir des pourcentages que des effectifs absolus. La fonction `proportions` permet de calculer la part associée chaque modalité de la variable. Elle s'applique à l'objet créé par la fonction `table`.

La part d'hommes/de femmes dans la population du département du Rhône

```{r}
tab_sexe <- table(rp$sexe)
proportions(tab_sexe)
```

La part de personnes en couple

```{r}
tab_couple <- table(rp$couple)
proportions(tab_couple)
```

On peut encore modifier ce tableau pour faciliter la lecture, par exemple en convertissant cette proportion en pourcentages

```{r}
# En décomposant ligne par ligne
tab_sexe <- table(rp$sexe)
tab_sexe <- proportions(tab_sexe)
tab_sexe <- tab_sexe*100
tab_sexe <- round(tab_sexe, 2)
tab_sexe

# En cumulant les fonctions
tab_sexe <- proportions(table(rp$sexe))
tab_sexe <- round(tab_sexe*100, 2)
tab_sexe
```

### Croiser des variables

Pour croiser deux variables, il suffit d'ajouter la deuxième colonne comme deuxième argument. La part d'hommes et de femmes en couple :

```{r}
tab_sexe_couple <- table(rp$sexe, rp$couple)
tab_sexe_couple
```

Pour les tableaux croisés, les fonctions `lprop` et `cprop` du package `questionr` permettent d'obtenir très facilement les pourcentages en ligne ou en colonne ainsi que les marges.

```{r}
library(questionr)

rprop(tab_sexe_couple)
cprop(tab_sexe_couple)
```

# Le recodage sur R

## Changer la nature d'une colonne

Le premier type de recodage consiste à changer la nature d'une colonne. On vérifie la nature d'une colonne avec la fonction `class` et on peut la modifier avec les fonctions de la forme `as.nature_désirée` : `as.integer`, `as.character` etc.

```{r}
class(rp$agerev)
rp$agerev <- as.numeric(rp$agerev)
class(rp$agerev)
```

```{r}
class(rp$sexe)
rp$sexe <- as.factor(rp$sexe)
class(rp$sexe)
```

## Tests et comparaison {#sec-tests}

L'essentiel du recodage s'opère avec des instructions logiques simples (égal, différent, inférieur ou supérieur à) que l'on peut combiner sur une variable ou plusieurs variables). On utilise pour cela des tests.

Un test est une opération logique de comparaison qui renvoie vrai (`TRUE`) ou faux (`FALSE`) pour chacun des éléments d'un vecteur.

Parmi les opérateurs de comparaison disponibles, on trouve notamment :

-   `==` qui teste l'égalité
-   `!=` qui teste la différence
-   `>`, `<`, `<=`, `>=` qui testent la supériorité ou l'infériorité
-   `%in%` qui teste l'appartenance à un ensemble de valeurs

Exemple le plus simple :

```{r}
2 == 3
```

```{r}
2 != 3
```

Exemple appliqué à un vecteur :

```{r}
x <- 1:10
x < 5
```

On peut combiner plusieurs tests avec les opérateurs logiques *et* (`&`) et *ou* (`|`). Ainsi, si on veut tester qu'une valeur est comprise entre 3 et 6 inclus, on peut faire :

```{r}
x >= 3 & x <= 6
```

Si on veut tester qu'une valeur est égale à "Bleu" ou à "Vert", on peut faire :

```{r}
vec <- c("Jaune", "Jaune", "Rouge", "Vert")
vec == "Jaune" | vec == "Vert"
```

À noter que dans ce cas, on peut utiliser l'opérateur `%in%`[^1], qui teste si une valeur fait partie des éléments d'un vecteur :

[^1]: Pour accéder à la page de documentation de fonctions comme `%in%`, on ne peut pas utiliser `?%in%`, qui renvoie une erreur. Vous pouvez faire `?"%in%"`, `help("%in%")` ou, dans ce cas, `?match`, car les deux fonctions sont documentées sur la même page d'aide.

```{r}
vec %in% c("Jaune", "Vert")
```

::: callout-warning
Attention, si on souhaite tester si une valeur `x` est inconnue (ou 'manquante'), c'est-à-dire si elle est codée `NA` (*Not Available*), faire le test `x == NA` *ne donnera pas le résultat escompté*. En effet, fidèle à sa réputation de rigueur informaticienne, pour R `NA == NA` ne vaut pas `TRUE` mais... `NA` (on ne sait pas si une valeur inconnue est égale à une autre valeur inconnue).

Pour tester si une valeur est inconnue (`NA`), il faut utiliser la fonction dédiée `is.na` et faire `is.na(x)`.

Cependant, par convention, `NA %in% NA` vaut `TRUE`.
:::

Enfin, on peut inverser un test avec l'opérateur *non* (`!`) :

```{r}
!(vec %in% c("Jaune", "Vert"))
```

## Le recodage sous condition

```{r}
library(tidyverse)
```


La fonction ifelse permet de faire une action sous condition : si l'âge est supérieur à 18, donne la valeur "majeur.e", sinon donne la valeur "mineur.e". case_when étend ce fonctionnement à plus d'une possibilité : si l'âge est supérieur à 18 donne "majeur.e", si l'âge est compris entre 18 et 64 donne "adulte", si l'âge est supérieur à 64 donne "senior".

Il faut associer ces fonctions à d'autres fonctions qui disent à R quoi faire avec le tableau. La fonction mutate permet de créer une nouvelle colonne. On pourra dire à R : crée une nouvelle colonne (mutate) à partir d'un test sur la valeur initiale de la variable (ifelse).


```{r}
# Voici deux versions du codage de l'âge des personnes recensées, soit la variable agerev. La première est lisible, la deuxième est commentée ligne par ligne.

# Version plus lisible sans les commentaires
rp <- mutate(
  rp,
  age_rec = 
    ifelse(
      agerev > 17,
      "Majeur.e",
      "Mineur.e"
    )
)

# Version commentée
rp <-
  # J'utilise la fonction mutate pour créer une colonne
  mutate(
    # Le premier argument de mutate, le tableau à transformer
    rp,
    # Le deuxième argument de mutate, le nom de la colonne à créer (à gauche du =) et la valeur que je lui donne (à droite du =)
    age_rec = 
      # Elle sera créée à l'aide du test opérée par la fonction ifelse
      ifelse(
        # Le premier argument de ifelse, la condition
        agerev > 17,
        # Le deuxième argument de ifelse, la valeur à donner si la condition est vérifiée
        "Majeur.e", 
        # Le troisième argument de ] ifelse, la valeur à donner si la condition n'est pas vérifié
        "Mineur.e"
        # Je ferme la parenthèse de la fonction ifelse
      )
    # Je ferme la parenthèse de la fonction mutate
  ) 

# On obtient bien une nouvelle variable/colonne nommée age_rec qui prend soit la valeur "Mineur.e", soit la valeur "Majeur.e"
```

Dès qu'on veut utiliser plus d'un test (par exemple, obtenir trois valeurs : mineur.e, adulte, senior), il faut utiliser la fonction case_when.

```{r}
# Version lisible
rp <- 
  mutate(
  rp,
  age_rec =
    case_when(
      agerev < 18 ~ "Mineur.e",
      agerev > 17 & agerev < 65 ~ "Adulte",
      agerev > 64 ~ "Senior"
    )
)


# Version commentée
rp <-
  # Je crée une variable grâce à la fonction mutat
  mutate(
    # Le premier argument, je transforme le tableau rp
    rp,
    # Le deuxième argument, la variable à créer
    age_rec = 
      # Qui sera créee grâce à la fonction case_when
      case_when(
        # À gauche du "~", c'est la condition, à droite la valeur
        # Si agerev est strictement inférieur à 18, alors la variable prendra la valeur "Mineur.e"
        agerev < 18 ~ "Mineur.e",
        # Si agerev est strictement supérieur à 17 ET qu'agerev est strictement inférieur à 65, alors la variable prendra la valeur "Adulte"
        agerev > 17 & agerev < 65 ~ "Adulte",
         # Si agerev est strictement supérieur à 64, alors la variable prendra la valeur "Senior"
        agerev > 64 ~ "Senior"
        # Je ferme la parenthèse de la fonction case_when
      )
     # Je ferme la parenthèse de la fonction mutate
  )
```

Nous n'avons pas spécifié la nature de notre nouvelle colonne/vecteur. On cherche ici à créer un facteur puisqu'on a une variable catégorielle. La fonction ``fct` permet de créer un vecteur et de spécifier l'ordre de ses modalités (quand on fera des tableaux ou des graphiques, on voudra que "Senior" apparaisse en dernier, et non entre "Mineur.e" et "Majeur.e" 
```{r}
# Un vecteur de type texte qui renseigne la catégorie d'âge de 6 personnes
cat_age <- c("Mineur.e", 
             "Adulte", 
             "Adulte", 
             "Senior", 
             "Mineur.e",
             "Senior")
# Le tri croisé ne donne pas quelque chose d'intuitif :
table(cat_age)
# La catégorie adulte apparaît avant mineur.e
# On le transforme en facteur
cat_age <-
  fct(cat_age, # Le premier argument, le facteur à transformer
      levels = # Le deuxième argument, les modalités (levels) avec l'ordre d'apparition 
        c("Mineur.e", "Adulte", "Senior")
      )
# Le problème est résolu
table(cat_age)
```

